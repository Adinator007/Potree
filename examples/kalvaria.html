<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="description" content="" />
    <meta name="author" content="" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Potree Viewer</title>

    <link rel="stylesheet" type="text/css" href="../build/potree/potree.css" />
    <link
      rel="stylesheet"
      type="text/css"
      href="../libs/jquery-ui/jquery-ui.min.css"
    />
    <link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css" />
    <link
      rel="stylesheet"
      type="text/css"
      href="../libs/spectrum/spectrum.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="../libs/jstree/themes/mixed/style.css"
    />
  </head>

  <body>
    <script src="../libs/jquery/jquery-3.1.1.min.js"></script>
    <script src="../libs/spectrum/spectrum.js"></script>
    <script src="../libs/jquery-ui/jquery-ui.min.js"></script>
    <script src="../libs/other/BinaryHeap.js"></script>
    <script src="../libs/tween/tween.min.js"></script>
    <script src="../libs/d3/d3.js"></script>
    <script src="../libs/proj4/proj4.js"></script>
    <script src="../libs/openlayers3/ol.js"></script>
    <script src="../libs/i18next/i18next.js"></script>
    <script src="../libs/jstree/jstree.js"></script>
    <script src="../build/potree/potree.js"></script>
    <script src="../libs/plasio/js/laslaz.js"></script>
    <script src="../libs/shapefile/shapefile.js"></script>

    <div
      class="potree_container"
      style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px"
    >
      <div
        id="potree_render_area"
        style="
          background-image: url('../build/potree/resources/images/background.jpg');
        "
      ></div>
      <div id="potree_sidebar_container"></div>
    </div>

    <script type="module">
      import * as THREE from "../libs/three.js/build/three.module.js";

      let selectedTreeId = null;
      let volume = null;

      window.viewer = new Potree.Viewer(
        document.getElementById("potree_render_area")
      );

      viewer.setEDLEnabled(true);
      viewer.setFOV(60);
      viewer.setPointBudget(1_000_000);
      viewer.setMinNodeSize(0);
      viewer.loadSettingsFromURL();

      viewer.setDescription("");

      viewer.loadGUI(() => {
        viewer.setLanguage("en");
        viewer.toggleSidebar();

        let section = $(`
        <h3 id="menu_meta" class="accordion-header ui-widget"><span>Tree Selector</span></h3>
        <div class="accordion-content ui-widget pv-menu-list"></div>
      `);
        let content = section.last();
        content.html(`
    <div class="pv-menu-list">
      <label for="tree_id">Tree ID:</label>
      <select id="tree_id"></select>
      <br /><br />
      <label for="radius_slider">Vicinity Radius (1-25m):</label>
      <input type="range" id="radius_slider" min="1" max="25" value="10" />
      <span id="radius_value">10m</span>
      <br /><br />
      <label for="x_slider">X Coordinate (-100 to 100):</label>
      <input type="range" id="x_slider" min="-100" max="100" value="0" />
      <span id="x_value">0</span>
      <br /><br />
      <label for="y_slider">Y Coordinate (-100 to 100):</label>
      <input type="range" id="y_slider" min="-100" max="100" value="0" />
      <span id="y_value">0</span>
      <br /><br />
      <button id="submit_button">Visualize</button>
    </div>
  `);

        section.first().click(() => content.slideToggle());
        section.insertBefore($("#menu_about"));

        const treeData = [];

        const parseTreeData = async (url) => {
          const response = await fetch(url);
          const text = await response.text();
          const lines = text.split("\n");

          for (const line of lines) {
            const parts = line.split(",");
            if (parts.length === 4) {
              treeData.push({
                id: parts[0],
                x: parseFloat(parts[1]),
                y: parseFloat(parts[2]),
                z: parseFloat(parts[3]),
              });
            }
          }

          populateTreeSelector(treeData);
        };

        const populateTreeSelector = (data) => {
          const treeIdSelect = document.getElementById("tree_id");
          data.forEach((tree) => {
            const option = document.createElement("option");
            option.value = tree.id;
            option.text = tree.id;
            treeIdSelect.add(option);
          });

          treeIdSelect.addEventListener("change", () => {
            selectedTreeId = treeIdSelect.value;
            console.log(`Selected Tree ID: ${selectedTreeId}`);

            const selectedTree = treeData.find(
              (tree) => tree.id === selectedTreeId
            );
            if (selectedTree) {
              const { x, y, z } = selectedTree;
              console.log(
                `Coordinates for selected tree ID (${selectedTreeId}):`,
                { x, y, z }
              );
              const radius = parseFloat(
                document.getElementById("radius_slider").value
              );
              updateVolumePosition(new THREE.Vector3(x, y, z), radius);
            }
          });
        };

        const updateVolumePosition = (center, radius) => {
          console.log(
            `Updating volume position with center: ${center}, radius: ${radius}`
          );

          if (volume) {
            volume.position.set(center.x, center.y, center.z);
            volume.scale.set(radius * 2, radius * 2, radius * 50);
            viewer.setClipTask(Potree.ClipTask.SHOW_INSIDE);
          }
        };

        document
          .getElementById("submit_button")
          .addEventListener("click", () => {
            const selectedId = document.getElementById("tree_id").value;
            const radius = parseFloat(
              document.getElementById("radius_slider").value
            );
            const selectedTree = treeData.find(
              (tree) => tree.id === selectedId
            );

            if (selectedTree) {
              const center = new THREE.Vector3(
                selectedTree.x,
                selectedTree.y,
                selectedTree.z
              );
              updateVolumePosition(center, radius);
            }
          });

        document
          .getElementById("radius_slider")
          .addEventListener("input", (event) => {
            document.getElementById(
              "radius_value"
            ).textContent = `${event.target.value}m`;

            if (selectedTreeId) {
              const selectedTree = treeData.find(
                (tree) => tree.id === selectedTreeId
              );
              if (selectedTree) {
                const center = new THREE.Vector3(
                  selectedTree.x,
                  selectedTree.y,
                  selectedTree.z
                );
                const radius = parseFloat(event.target.value);
                updateVolumePosition(center, radius);
              }
            }
          });

        document
          .getElementById("x_slider")
          .addEventListener("input", (event) => {
            document.getElementById(
              "x_value"
            ).textContent = `${event.target.value}`;
          });

        document
          .getElementById("y_slider")
          .addEventListener("input", (event) => {
            document.getElementById(
              "y_value"
            ).textContent = `${event.target.value}`;
          });

        parseTreeData("/examples/kalvaria_pcd/torzs_koordinatak_plusz.txt");
      });

      // Define shapeNode
      const shapeNode = new THREE.Group();
      viewer.scene.scene.add(shapeNode);

      // Load your point cloud
      const loadPointCloud = async (url, name) => {
        try {
          const response = await fetch(url);
          const metadata = await response.json();
          const offset = metadata.offset;

          Potree.loadPointCloud(url, name, async function (e) {
            if (!e.pointcloud) {
              console.error("Failed to load point cloud");
              return;
            }

            console.log("Point cloud loaded successfully", e.pointcloud);

            let pointcloud = e.pointcloud;
            let center = pointcloud.position;

            console.log("Point cloud position:", pointcloud.position);
            console.log("Point cloud boundingBox:", pointcloud.boundingBox);

            let pointMaterial = pointcloud.material;
            pointMaterial.size = 1;
            pointMaterial.pointSizeType = Potree.PointSizeType.ADAPTIVE;
            pointMaterial.uniforms.uShadowColor.value = [0.0, 0, 0];

            console.log("Point cloud center position:", center);

            viewer.scene.view.position.set(center.x, center.y, center.z + 100);
            viewer.scene.view.lookAt(center);

            viewer.scene.addPointCloud(pointcloud);

            if (pointcloud.nodes) {
              pointcloud.nodes.traverse((node) => {
                node.visible = true;
              });
            }

            const zShiftAmount = offset[2] + 7;

            const loader = new Potree.ShapefileLoader();

            const loadShapefile = async (path, color, zShift = 0) => {
              try {
                const shpPoints = await loader.load(path);

                if (shpPoints && shpPoints.node) {
                  shpPoints.node.position.set(0, 0, zShift);
                  shpPoints.node.updateMatrixWorld(true);
                  console.log("SHAPE type: ", shpPoints);

                  shpPoints.node.traverse((node) => {
                    if (node.material) {
                      node.material.color.set(color);
                    }
                  });

                  shapeNode.add(shpPoints.node);
                } else {
                  console.error(
                    "Loaded shapefile node is not a THREE.Object3D instance or is undefined:",
                    shpPoints.node
                  );
                }
              } catch (error) {
                console.error(`Error loading shapefile (${path}):`, error);
              }
            };

            const modifyShapefile = (shapefileNode, newColor, newZShift) => {
              console.log(
                "Starting to modify shapefile...",
                newColor,
                newZShift
              );

              shapefileNode.traverse((node) => {
                console.log("Traversing node:", node);

                if (node.isObject3D) {
                  console.log(
                    "Node is a THREE.Object3D instance. Modifying position..."
                  );
                  node.position.z += newZShift;
                  console.log(`New Z position: ${node.position.z}`);
                  node.updateMatrixWorld(true);
                } else {
                  console.log("Node is not a THREE.Object3D instance.");
                }

                if (node.material) {
                  console.log("Node has material. Changing color...");
                  node.material.color.set(newColor);
                  console.log(`New color: ${node.material.color.getStyle()}`);
                } else {
                  console.log("Node does not have material.");
                }
              });

              console.log("Finished modifying shapefile.");
            };

            // Usage example
            (async () => {
              await loadShapefile(
                "/examples/kalvaria_pcd/tree_height_lines.shp",
                new THREE.Color(0.3, 0.3, 1)
              );

              // Delay for 5 seconds before modifying the shapefile
              setTimeout(() => {
                console.log("Modifying shapefile after 5 seconds...");
                modifyShapefile(shapeNode, 0x00ff00, 5);
              }, 5000);
            })();
            // await loadShapefile(
            //   "/examples/kalvaria_pcd/convex_hulls.shp",
            //   new THREE.Color(1, 0, 0)
            // );
            // await loadShapefile(
            //   "/examples/kalvaria_pcd/FaKoronaPoligonok.shp",
            //   new THREE.Color(0, 1, 0),
            //   zShiftAmount
            // );

            const addVolume = (name, scale, position, visible) => {
              volume = new Potree.BoxVolume();
              volume.name = name;
              volume.scale.set(scale.x, scale.y, scale.z);
              volume.position.set(position.x, position.y, position.z);
              volume.clip = true;
              volume.visible = visible;

              viewer.scene.addVolume(volume);
            };

            const scale = { x: 50, y: 50, z: 1000 };
            const positionVisible = {
              x: center.x,
              y: center.y,
              z: center.z,
            };

            addVolume("Visible", scale, positionVisible, true);

            viewer.setClipTask(Potree.ClipTask.SHOW_INSIDE);
          });
        } catch (error) {
          console.error("Failed to load point cloud", error);
        }
      };

      loadPointCloud("/examples/kalvaria_pcd/metadata.json", "Kalvaria");

      viewer.addEventListener("update", () => {
        const size = viewer.renderer.getSize(new THREE.Vector2());

        shapeNode.traverse((node) => {
          if (node.setResolution) {
            node.setResolution(size.width, size.height);
          }
        });
      });

      viewer.onGUILoaded(() => {
        let tree = $(`#jstree_scene`);
        let parentNode = "other";

        shapeNode.traverse((node) => {
          if (node instanceof THREE.Object3D) {
            let shapefileID = tree.jstree(
              "create_node",
              parentNode,
              {
                text: "tree_height_lines",
                icon: `${Potree.resourcePath}/icons/triangle.svg`,
                object: node,
                data: node,
              },
              "last",
              false,
              false
            );
            tree.jstree(
              node.visible ? "check_node" : "uncheck_node",
              shapefileID
            );
          }
        });
      });
    </script>
  </body>
</html>
